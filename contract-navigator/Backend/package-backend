// server.js - Complete Backend for Contract Navigator
const express = require('express');
const multer = require('multer');
const cors = require('cors');
const fs = require('fs').promises;
const path = require('path');
const PDFParser = require('pdf2json');
const mammoth = require('mammoth');
const jsPDF = require('jspdf').jsPDF;
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// File upload configuration
const storage = multer.diskStorage({
    destination: 'uploads/',
    filename: (req, file, cb) => {
        const uniqueName = Date.now() + '-' + Math.round(Math.random() * 1E9) + path.extname(file.originalname);
        cb(null, uniqueName);
    }
});

const upload = multer({ 
    storage: storage,
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
    fileFilter: (req, file, cb) => {
        const allowedTypes = ['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
        if (allowedTypes.includes(file.mimetype)) {
            cb(null, true);
        } else {
            cb(new Error('Invalid file type'));
        }
    }
});

// Create uploads directory if it doesn't exist
const createUploadsDir = async () => {
    try {
        await fs.access('uploads');
    } catch {
        await fs.mkdir('uploads');
    }
};
createUploadsDir();

// In-memory storage for demo (use database in production)
const analyses = new Map();

// Contract analysis prompt template
const ANALYSIS_PROMPT = `You are a professional contract attorney. Analyze the following contract and provide a detailed risk assessment.

Please provide your response in the following JSON format:
{
    "summary": "Brief executive summary of the contract",
    "riskLevel": "HIGH/MEDIUM/LOW",
    "risks": [
        {
            "type": "HIGH/MEDIUM/LOW",
            "title": "Risk title",
            "description": "Detailed description",
            "recommendation": "What to do about it",
            "clauseText": "The specific clause text that's problematic"
        }
    ],
    "highlights": [
        {
            "text": "exact text to highlight",
            "risk": "HIGH/MEDIUM/LOW",
            "note": "margin note for this highlight"
        }
    ],
    "recommendations": [
        "Specific actionable recommendation 1",
        "Specific actionable recommendation 2"
    ]
}

Contract to analyze:
`;

// Helper function to extract text from PDF
function extractTextFromPDF(filePath) {
    return new Promise((resolve, reject) => {
        const pdfParser = new PDFParser();
        
        pdfParser.on('pdfParser_dataError', reject);
        pdfParser.on('pdfParser_dataReady', (pdfData) => {
            const text = pdfParser.getRawTextContent();
            resolve(text);
        });
        
        pdfParser.loadPDF(filePath);
    });
}

// Helper function to extract text from DOCX
async function extractTextFromDOCX(filePath) {
    const buffer = await fs.readFile(filePath);
    const result = await mammoth.extractRawText({ buffer });
    return result.value;
}

// Helper function to call Claude API
async function analyzeWithClaude(contractText) {
    try {
        const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "x-api-key": process.env.CLAUDE_API_KEY,
                "anthropic-version": "2023-06-01"
            },
            body: JSON.stringify({
                model: "claude-3-sonnet-20240229",
                max_tokens: 4000,
                messages: [
                    {
                        role: "user",
                        content: ANALYSIS_PROMPT + contractText
                    }
                ]
            })
        });

        if (!response.ok) {
            throw new Error(`Claude API error: ${response.status}`);
        }

        const data = await response.json();
        const analysisText = data.content[0].text;
        
        // Parse JSON response from Claude
        try {
            return JSON.parse(analysisText);
        } catch (parseError) {
            // If Claude doesn't return valid JSON, create a structured response
            return {
                summary: "Analysis completed",
                riskLevel: "MEDIUM",
                risks: [{
                    type: "MEDIUM",
                    title: "General Contract Review",
                    description: analysisText,
                    recommendation: "Please review the detailed analysis provided.",
                    clauseText: "Full contract"
                }],
                highlights: [],
                recommendations: ["Review all terms carefully", "Consider legal counsel"]
            };
        }
    } catch (error) {
        console.error('Claude API error:', error);
        throw error;
    }
}

// Generate annotated PDF with highlights
function generateAnnotatedPDF(originalText, analysis, filename) {
    const doc = new jsPDF();
    const pageHeight = doc.internal.pageSize.height;
    let yPosition = 20;
    
    // Add title
    doc.setFontSize(16);
    doc.text('Contract Analysis Report', 20, yPosition);
    yPosition += 20;
    
    // Add summary
    doc.setFontSize(12);
    doc.text('Executive Summary:', 20, yPosition);
    yPosition += 10;
    
    const summaryLines = doc.splitTextToSize(analysis.summary, 170);
    doc.text(summaryLines, 20, yPosition);
    yPosition += summaryLines.length * 5 + 10;
    
    // Add risk level
    doc.text(`Overall Risk Level: ${analysis.riskLevel}`, 20, yPosition);
    yPosition += 15;
    
    // Add risks
    doc.setFontSize(14);
    doc.text('Identified Risks:', 20, yPosition);
    yPosition += 10;
    
    analysis.risks.forEach((risk, index) => {
        if (yPosition > pageHeight - 30) {
            doc.addPage();
            yPosition = 20;
        }
        
        doc.setFontSize(12);
        doc.setTextColor(risk.type === 'HIGH' ? 255 : risk.type === 'MEDIUM' ? 255 : 0, 
                         risk.type === 'HIGH' ? 0 : risk.type === 'MEDIUM' ? 165 : 0, 0);
        doc.text(`${index + 1}. ${risk.title} (${risk.type} RISK)`, 20, yPosition);
        doc.setTextColor(0, 0, 0);
        yPosition += 8;
        
        const descLines = doc.splitTextToSize(risk.description, 170);
        doc.text(descLines, 25, yPosition);
        yPosition += descLines.length * 5 + 5;
        
        const recLines = doc.splitTextToSize(`Recommendation: ${risk.recommendation}`, 170);
        doc.text(recLines, 25, yPosition);
        yPosition += recLines.length * 5 + 10;
    });
    
    const pdfPath = `uploads/annotated-${filename}.pdf`;
    doc.save(pdfPath);
    return pdfPath;
}

// API Routes

// Upload and start analysis
app.post('/api/upload-contract', upload.single('contract'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ error: 'No file uploaded' });
        }

        const analysisId = Date.now().toString();
        const filePath = req.file.path;
        
        // Store initial analysis record
        analyses.set(analysisId, {
            id: analysisId,
            filename: req.file.originalname,
            status: 'uploaded',
            uploadTime: new Date(),
            filePath: filePath
        });

        res.json({
            analysisId: analysisId,
            filename: req.file.originalname,
            status: 'uploaded'
        });

    } catch (error) {
        console.error('Upload error:', error);
        res.status(500).json({ error: 'Upload failed: ' + error.message });
    }
});

// Start AI analysis
app.post('/api/analyze-contract/:analysisId', async (req, res) => {
    try {
        const { analysisId } = req.params;
        const analysis = analyses.get(analysisId);
        
        if (!analysis) {
            return res.status(404).json({ error: 'Analysis not found' });
        }

        // Update status
        analysis.status = 'extracting_text';
        analyses.set(analysisId, analysis);

        // Extract text from document
        let contractText;
        const fileExtension = path.extname(analysis.filePath).toLowerCase();
        
        if (fileExtension === '.pdf') {
            contractText = await extractTextFromPDF(analysis.filePath);
        } else if (fileExtension === '.docx') {
            contractText = await extractTextFromDOCX(analysis.filePath);
        } else {
            throw new Error('Unsupported file format');
        }

        // Update status
        analysis.status = 'analyzing_with_ai';
        analysis.contractText = contractText;
        analyses.set(analysisId, analysis);

        // Send to Claude for analysis
        const aiAnalysis = await analyzeWithClaude(contractText);

        // Update status
        analysis.status = 'generating_pdf';
        analysis.aiAnalysis = aiAnalysis;
        analyses.set(analysisId, analysis);

        // Generate annotated PDF
        const annotatedPdfPath = generateAnnotatedPDF(contractText, aiAnalysis, analysisId);

        // Final update
        analysis.status = 'completed';
        analysis.annotatedPdfPath = annotatedPdfPath;
        analysis.completedTime = new Date();
        analyses.set(analysisId, analysis);

        res.json({
            analysisId: analysisId,
            status: 'completed',
            analysis: aiAnalysis
        });

    } catch (error) {
        console.error('Analysis error:', error);
        
        // Update analysis with error
        const analysis = analyses.get(req.params.analysisId);
        if (analysis) {
            analysis.status = 'error';
            analysis.error = error.message;
            analyses.set(req.params.analysisId, analysis);
        }

        res.status(500).json({ error: 'Analysis failed: ' + error.message });
    }
});

// Get analysis status
app.get('/api/analysis-status/:analysisId', (req, res) => {
    const { analysisId } = req.params;
    const analysis = analyses.get(analysisId);
    
    if (!analysis) {
        return res.status(404).json({ error: 'Analysis not found' });
    }

    res.json({
        id: analysis.id,
        filename: analysis.filename,
        status: analysis.status,
        uploadTime: analysis.uploadTime,
        completedTime: analysis.completedTime,
        error: analysis.error
    });
});

// Get analysis results
app.get('/api/analysis-results/:analysisId', (req, res) => {
    const { analysisId } = req.params;
    const analysis = analyses.get(analysisId);
    
    if (!analysis) {
        return res.status(404).json({ error: 'Analysis not found' });
    }

    if (analysis.status !== 'completed') {
        return res.status(400).json({ error: 'Analysis not completed' });
    }

    res.json({
        id: analysis.id,
        filename: analysis.filename,
        analysis: analysis.aiAnalysis,
        contractText: analysis.contractText
    });
});

// Download annotated PDF
app.get('/api/download-pdf/:analysisId', async (req, res) => {
    try {
        const { analysisId } = req.params;
        const analysis = analyses.get(analysisId);
        
        if (!analysis || analysis.status !== 'completed') {
            return res.status(404).json({ error: 'Analysis not found or not completed' });
        }

        const pdfPath = analysis.annotatedPdfPath;
        const pdfBuffer = await fs.readFile(pdfPath);
        
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="annotated-${analysis.filename}.pdf"`);
        res.send(pdfBuffer);

    } catch (error) {
        console.error('PDF download error:', error);
        res.status(500).json({ error: 'PDF download failed' });
    }
});

// Health check
app.get('/api/health', (req, res) => {
    res.json({ 
        status: 'healthy', 
        timestamp: new Date(),
        activeAnalyses: analyses.size 
    });
});

// Error handling middleware
app.use((error, req, res, next) => {
    console.error('Server error:', error);
    res.status(500).json({ error: 'Internal server error' });
});

// Start server
app.listen(PORT, () => {
    console.log(`ðŸš€ Contract Navigator Backend running on port ${PORT}`);
    console.log(`ðŸ“Š API endpoints available at http://localhost:${PORT}/api/`);
    console.log(`ðŸ’¡ Don't forget to add CLAUDE_API_KEY to your .env file`);
});
